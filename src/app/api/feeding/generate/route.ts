import { NextRequest, NextResponse } from 'next/server';

// Import stores from other routes (in a real app, these would be in a shared module)
// For this demo, we'll use separate stores but in production these should be unified
const feedingStore = new Map<string, any[]>();
const scheduleStore = new Map<string, any[]>();

/**
 * Generate feeding records from schedules for a date range
 * POST /api/feeding/generate
 * Body: { startDate: string, endDate: string, petId?: string }
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { startDate, endDate, petId } = body;

    if (!startDate || !endDate) {
      return NextResponse.json(
        { success: false, error: 'startDate and endDate are required' },
        { status: 400 }
      );
    }

    const userId = req.headers.get('x-user-id') || 'demo-user';

    // Get all schedules for the user
    let schedules = scheduleStore.get(userId) || [];

    if (petId) {
      schedules = schedules.filter(s => s.petId === petId);
    }

    // Filter only active schedules
    schedules = schedules.filter(s => s.active);

    // Get existing feeding records to avoid duplicates
    const existingRecords = feedingStore.get(userId) || [];

    const generatedRecords: any[] = [];
    const start = new Date(startDate);
    const end = new Date(endDate);

    // Generate records for each day in the range
    for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
      const dayOfWeek = date.getDay() === 0 ? 7 : date.getDay(); // Convert to 1-7 (Monday-Sunday)
      const dateString = date.toISOString().split('T')[0];

      for (const schedule of schedules) {
        // Check if this schedule applies to this day
        const shouldGenerate =
          (schedule.frequency === 'daily') ||
          (schedule.frequency === 'weekdays' && dayOfWeek >= 1 && dayOfWeek <= 5) ||
          (schedule.frequency === 'weekends' && (dayOfWeek === 6 || dayOfWeek === 7)) ||
          (schedule.days && schedule.days.includes(dayOfWeek));

        if (!shouldGenerate) continue;

        // Check if a record already exists for this schedule on this date
        const recordExists = existingRecords.some(r =>
          r.petId === schedule.petId &&
          r.mealType === schedule.mealType &&
          new Date(r.date).toISOString().split('T')[0] === dateString
        );

        if (recordExists) continue;

        // Create the feeding record
        const dateTime = new Date(`${dateString}T${schedule.time}:00`);
        const newRecord = {
          id: `feeding_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          userId,
          petId: schedule.petId,
          date: dateTime.toISOString(),
          mealType: schedule.mealType,
          foodType: schedule.foodType,
          amount: schedule.amount,
          unit: schedule.unit,
          notes: schedule.notes || 'Auto-generated from schedule',
          autoGenerated: true,
          scheduleId: schedule.id,
          confirmed: false, // Requires user confirmation
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };

        generatedRecords.push(newRecord);
      }
    }

    // Add generated records to the store
    if (generatedRecords.length > 0) {
      const userRecords = feedingStore.get(userId) || [];
      userRecords.push(...generatedRecords);
      feedingStore.set(userId, userRecords);
    }

    return NextResponse.json({
      success: true,
      data: {
        generated: generatedRecords.length,
        records: generatedRecords,
      },
    }, { status: 201 });
  } catch (error) {
    console.error('Generate feeding records error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to generate feeding records' },
      { status: 500 }
    );
  }
}

/**
 * Get unconfirmed auto-generated feeding records
 * GET /api/feeding/generate?petId=xxx
 */
export async function GET(req: NextRequest) {
  try {
    const userId = req.headers.get('x-user-id') || 'demo-user';
    const { searchParams } = new URL(req.url);
    const petId = searchParams.get('petId');

    let records = feedingStore.get(userId) || [];

    // Filter for auto-generated and unconfirmed records
    records = records.filter(r => r.autoGenerated && !r.confirmed);

    if (petId) {
      records = records.filter(r => r.petId === petId);
    }

    // Group by date for easier confirmation
    const grouped = records.reduce((acc: any, record: any) => {
      const date = new Date(record.date).toISOString().split('T')[0];
      if (!acc[date]) {
        acc[date] = [];
      }
      acc[date].push(record);
      return acc;
    }, {});

    return NextResponse.json({
      success: true,
      data: {
        total: records.length,
        records,
        byDate: grouped,
      },
    });
  } catch (error) {
    console.error('Get unconfirmed records error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch unconfirmed records' },
      { status: 500 }
    );
  }
}
